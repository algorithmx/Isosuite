# SMODES, Version 1.2.3, June 1998

#Harold T. Stokes and Dorian M. Hatch
#Department of Physics and Astronomy, Brigham Young University, Provo, Utah
#e-mail: stokesh@byu.edu
#
#This program may be distributed without restriction, but if it is used in
#research that results in publications, the use of this program should be
#acknowledged.
#
#This program calculates the displacement modes in a crystal which brings the
#dynamical matrix to block-diagonal form, with the smallest possible blocks.  It
#also chooses the modes so that its unit cell is as small as possible and its
#point-group symmetry is as high as possible.
#
#Input comes from standard input which may be redirected from a file.  Output
#goes to standard output which may also be redirected to a file.  See the files,
#smodes_sample.in and smodes_sample.out, for an example of input and output to
#the program.
#

## --------------------------------------------------------------------------------

# from International Tables for Crystallography
#-----------------------
#Conventions for Wyckoff
#-----------------------
#Note that for Wyckoff position g, a value must be given for x, even though x
#does not appear in the coordinates of the position.  The program interprets
#the first number to be x, the second number to be y, and the third number to
#be z, regardless of which of these are actually used in evaluating the
#coordinates of the atomic position.
#The program uses the settings in the International Tables for Crystallography.
#Sometimes more than one setting is given in the Tables.  This program uses:
#(a) for monoclinic groups, unique axis b and cell choice 1, (b) for groups
#where there are two choices of origin, the second choice (where the point of 
#inversion is at the origin), (c) for rhombohedral groups, the hexagonal axes.
#Sometimes the convention for the values of x,y,z used in the program do not
#follow the one in the Tables.  Always check the output to determine where
#the program actually put each atom.

##

function input_smodes(
    space_group_number::Int,
    cell_parameters::Tuple,
    atom_wyckoff_params::Dict,
    k_vectors::Vector{String}
    )

    OUTP = String[]

    #line 1.  Title line.  This line can contain any string of characters, including
    #no characters, and will be copied onto the first line of output.
    TITLE = "Automatically generated by function input_smodes()."
    push!(OUTP, TITLE)

    #line 2.  Space group number, 1 through 230.
    push!(OUTP, "$(space_group_number)")
    
    #line 3.  Lattice parameters, a,b,c,alpha,beta,gamma.  Angles should be given
    #in units of degrees.
    CELL_PARAM = join(cell_parameters, " ")
    push!(OUTP, CELL_PARAM)
    
    #line 4.  Number of inequivalent atomic positions in the unit cell.  Atoms which
    #are at different sites of the same Wyckoff position are at equivalent positions.
    N_INEQUIV_POS = string(length(atom_wyckoff_params))
    push!(OUTP, N_INEQUIV_POS)
    
    #line 5a, 5b, 5c...  The atomic symbol and its position.  Each inequivalent 
    #atomic position should be on a separate line.  The atomic symbol can be
    #any character string the user wants to use to identify the atom at that
    #position.  The position is denoted by a lower-case letter (the symbol for the 
    #Wyckoff position given in the International Tables for Crystallography), 
    #followed by 3 numbers, the values of x,y,z.  These numbers are unnecessary if 
    #the Wyckoff position is at a point of symmetry and has no degrees of freedom 
    #in its coordinates.
    #Examples:  Space group #204
    #     Cu b              Cu atom at Wyckoff position b: (0,1/2,1/2)
    #     Mg2+ e 0.15       Mg2+ ion at Wyckoff position e: (x,0,1/2)=(0.15,0,1/2)
    #     O g 0 0.22 -0.09  O atom at Wyckoff position g: (0,y,z)=(0,0.22,-0.09)
    POS = [ join([string(k), string(v[1]), join((length(v)>1 ? string.(v[2:end]) : String[])," ")], " ")
            for (k,v) ∈ atom_wyckoff_params ]
    OUTP = [OUTP; POS]
    
    #line 6.  Number of different k vectors to be treated.
    N_KVECS = string(length(k_vectors))
    push!(OUTP, N_KVECS)
    
    #line 7a,7b,7c...  The k vectors to be treated, each on a different line.
    #(1) The symbols for the k vectors follow the convention of Miller and Love.
    #(2) Greek letters gamma, delta, sigma, lambda are denoted by GM, DT, SM, LD,
    #respectively.  The general point is denoted by GP.  
    #(3) Some k vectors must be further specified by one or more parameters, 
    #denoted by alpha,beta,gamma (not the same as the 3 angles given on line 3). 
    # Each parameter must be entered as a ratio of two integers.
    #Examples:  Space group 115
    #     GM               Gamma point, k=(0,0,0)
    #     Z                Z point, k=(0,0,1/2)
    #     DT 1/4           Point on delta line, k=(0,0,alpha)=(0,0,1/4)
    #     GM DT            Gamma point with longitudinal modes along the direction
    #                      of the delta line, (0,0,1)
    #For the gamma point (k=0), a direction may be given for the longitudinal mode,
    #as in the last example above.  The direction is given as one of the k lines
    #of symmetry.  The program separates the longitudinal mode from the transverse
    #modes in the output.
    
    KVECS = k_vectors
    OUTP = [OUTP; KVECS]
    
    return join(STRPRM(OUTP), "\n")
end

##--------------------------------------------------------------------------------

function process_A_irrep_block(LINES)
    @inline EOF(k,L) = (k>=length(L)) || startswith(L[k],"End of output")
    @inline parse3f(s) = parse.(Float64, strip.(SPLTS(s)))
    @inline parsef(s) = parse(Float64, s)

    LINES = STRPRM(LINES)
    summary = Dict{String,Any}()
    h = 1

    #(6) Irreducible representation (irrep) symbol, following the convention of
    #Miller and Love. For k=0, the conventional symbol for point group irrep
    #is also given.
    summary["name"] = SPLTS1(LINES[h]) .|> strip |> last
    h += 1

    #(7) Degeneracy of each mode.  This is the dimension of the irrep.
    summary["degeneracy"] = parse( Int, SPLTC(LINES[h]) .|> strip |> last )
    h += 1
    
    #(8) Total number of modes for this irrep, including all of the degenerate modes.
    summary["number of modes"] = parse( Int, SPLTC(LINES[h]) .|> strip |> last )
    h += 1

    #(9) For k=0, some of the modes may be translational, i.e., they describe a 
    #translation of the entire crystal.  If there are any among the modes 
    #for a particular irrep, the number of such translation modes are given here
    #(10) If the modes are IR-active, this is indicated.  This only occurs for k=0.
    #(11) If the modes are raman-active, this is indicated.  This only occurs for
    #k=0.
    irrep_info = String[]
    while !occursin("Vectors defining superlattice", LINES[h])
        push!(irrep_info, LINES[h])
        h += 1
    end
    summary["irrep info"] = irrep_info

    #(12) Basis vectors of the lattice describing the distorted crystal.  This 
    #lattice is primitive, but the basis vectors are given in cartesian coordinates, 
    #in terms of an orthonormal set of basis vectors (i,j,k), consistent with the
    #values given for the lattice parameters, a,b,c,alpha,beta,gamma.
    supercell_basis = zeros(Float64,3,3)
    if occursin("Vectors defining superlattice", LINES[h])
        supercell_basis[:,1] = parse3f(LINES[h+1])
        supercell_basis[:,2] = parse3f(LINES[h+2])
        supercell_basis[:,3] = parse3f(LINES[h+3])
    end
    h += 4
    summary["supercell basis"] = supercell_basis

    #(13) Position of each atom in the unit cell, given in the same cartesian
    #coordinates as the basis vectors of the lattice in (12).
    atom_pos = []
    @inline parse_atm_pos(l5) = (t5 = SPLTS(l5); (parse(Int,t5[1]), String(t5[2]), parsef.(t5[3:5])))
    if occursin("atom", LINES[h]) && occursin("type", LINES[h]) && occursin("position", LINES[h])
        h += 1
        cnt = 1
        while ! (EOF(h,LINES) || occursin("Symmetry modes",LINES[h]))
            (atm_id, atm_name, atm_coords) = parse_atm_pos(LINES[h])
            push!( atom_pos, atm_name => atm_coords )
            @assert cnt == atm_id
            h += 1
            cnt += 1
        end
    end
    summary["atom positions"] = atom_pos

    #(14) Symmetry modes.  Each symmetry mode defines a coordinate
    #transformation which brings the dynamical matrix to block diagonal form.
    #(15) If any of these symmetry modes are translational modes, the number of
    #such modes is given.
    summary["modes info"] = String[]
    if occursin("Symmetry modes", LINES[h])
        if occursin("translational modes", LINES[h+1])
            summary["modes info"] = [summary["modes info"]; LINES[h+1]]
            h += 2
        else
            h += 1
        end
    end

    @assert (occursin("atom", LINES[h]) && occursin("type", LINES[h]) && occursin("displacement", LINES[h]))  LINES[h]
    h += 1

    #(16) Each symmetry mode is given.  The mode is defined by a displacement of
    #like atoms in the unit cell.  The displacements are given in the same cartesian
    #coordinates as the basis vectors of the lattice in (12) and the atomic positions
    #in (13).
    symm_modes = []
    s_mode = []
    while ! (EOF(h,LINES) || startswith(LINES[h],"***"))
        if startswith(LINES[h],"---") # skip separators
            h += 1
            if length(s_mode)>0
                push!( symm_modes, s_mode )
            end
            s_mode = []
            continue
        else
            #   7   Cu    -1.00000   0.00000   0.00000
            content = strip.(split(LINES[h],' ',keepempty=false))
            atm_id = parse(Int,content[1])
            atm_lb = content[2]
            atm_dp = parse.(Float64,content[3:5])
            push!( s_mode, (atm_id, atm_lb, atm_dp) )
            h += 1
        end
    end
    if length(s_mode)>0
        push!( symm_modes, s_mode )
    end
    summary["symmetry modes"] = symm_modes

    return summary
end

##

#modes = process_A_irrep_block(split(example_block2,'\n',keepempty=false)) ;

##

function process_irrep_blocks(LINES)
    @inline EOF(k,L) = (k>=length(L)) || startswith(L[k],"End of output")

    #(14) The next irrep for the k vector is given, and (6) through (16) are
    #repeated.
    p = 1
    IRREPS = []
    while ! (EOF(p,LINES) || startswith(LINES[p+1],"k vector"))
        if startswith(LINES[p],'*')
            p += 1
            continue
        else
            pc = p
            while ! (EOF(pc,LINES) || startswith(LINES[pc],"***")) pc += 1 end
            push!(IRREPS, process_A_irrep_block(LINES[p:pc]))
            p = pc
        end
    end

    return IRREPS, p
end

##

function translate_smodes_result(
    RESULT_STR::String,
    atom_wyckoff_params::Dict,
    k_vectors::Vector{String},
    )
    take1(x) = first(split(x,' ',keepempty=false))
    KVS = Set(take1.(k_vectors))
    RESULT_LINES = STRPRM(SPLTN(RESULT_STR))

    #(1) title line, copied from the first line in the input.
    l = 1
    while !startswith(RESULT_LINES[l],"Space Group") l += 1 end

    #(2) space group number and symbol
    @assert occursin("Space Group:",RESULT_LINES[l])
    SG = parse(Int, SPLTS(RESULT_LINES[l+1])[1])
    l += 2

    #(3) lattice parameters: a,b,c, alpha(deg),beta(deg),gamma(deg)
    @assert occursin("Lattice Parameters",RESULT_LINES[l])
    LATTICE_PARAMS = parse.(Float64, SPLTS(RESULT_LINES[l+1]))
    l += 2

    #(4) Wyckoff position of each inequivalent atomic site in the unit cell
    @assert occursin("Wyckoff position",RESULT_LINES[l])
    atoms = collect(keys(atom_wyckoff_params))
    ATOM_WYCK = []
    l += 1
    while !startswith(RESULT_LINES[l],'*')
        a,w = SPLTS(RESULT_LINES[l])
        @assert a ∈ atoms
        push!(ATOM_WYCK, a=>w)
        l += 1
    end
    l += 1

    @inline EOF(k,L) = (k>=length(L)) || startswith(L[k],"End of output")

    #(15) When all of the irreps for the k vector have been given, the next k
    #vector is given, and (5) through (14) are repeated.
    KVEC_IRREPS = []
    while ! EOF(l, RESULT_LINES)
        if startswith(RESULT_LINES[l],'*')
            l += 1
            continue
        else
            if startswith(RESULT_LINES[l],"k vector")
                #(5) k vector symbol and coordinates.  The coordinates are given in terms of
                #the basis vectors of the reciprocal lattice of the CONVENTIONAL lattice given
                #in International Tables for Crystallography.  Note that k vectors in Miller and
                #Love are given in terms of basis vectors of primitive lattices and may not
                #appear the same as the output of this program.
                kvec   = split(replace(RESULT_LINES[l], "k vector"=>""), '=', keepempty=false) .|> strip |> Tuple
                @assert kvec[1] ∈ KVS
                l += 2
                irreps, jump_lines = process_irrep_blocks(RESULT_LINES[l:end])
                push!(KVEC_IRREPS, kvec=>irreps)
                l += jump_lines
            end
        end
    end
    
    return Dict("space group"=>SG, 
                "lattice parameters"=>LATTICE_PARAMS, 
                "atom positions"=>ATOM_WYCK, 
                "irreps"=>KVEC_IRREPS)
end

## --------------------------------------------------------------------------------


